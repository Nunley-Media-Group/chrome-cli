# Spec Retrospective

**Last Updated**: 2026-02-17
**Defect Specs Analyzed**: 33
**Learnings Generated**: 19

---

## How to Use This Document

This document is automatically generated by `/running-retrospectives` and read by
`/writing-specs` during Phase 1 (SPECIFY). When writing new feature specs, apply
these transferable patterns to new feature contexts — adapt each learning to the
current feature's domain rather than applying it literally.

---

## Missing Acceptance Criteria

Defects caused by scenarios that the original feature spec did not cover at all.

| Learning | Recommendation | Evidence (defect specs) |
|----------|---------------|------------------------|
| When features span multiple invocations or depend on event-driven state from prior sessions, specs must include ACs that verify state persistence and visibility across process or session boundaries. Status/query commands and multi-step workflows are especially vulnerable when each invocation resets connection state. | For any multi-step workflow or status/query command, include an AC that spans at least two independent invocations separated by a process/session boundary, verifying state established in step A is observable in step B. If the underlying connection model resets between invocations, require an explicit persistence mechanism or redesign the workflow to avoid cross-invocation state. | .claude/specs/74-fix-emulate-status-inaccurate-state/, .claude/specs/76-fix-perf-cross-invocation-state-loss/, .claude/specs/85-fix-emulate-overrides-persistence/, .claude/specs/99-fix-dialog-handle-no-dialog-open/, .claude/specs/102-fix-network-list-empty-array/, .claude/specs/103-fix-console-read-empty-array/, .claude/specs/134-fix-dialog-info-wrong-type-empty-message/ |
| ACs for write/mutation commands that verify success only through the command's own output do not test whether the state change is observable by subsequent independent reads. In eventually-consistent external systems, the state may not propagate before the command exits. | For any command that mutates shared state, include at least one AC that cross-validates the mutation through a subsequent independent read command (e.g., "after activate X, list shows X as active"). Add explicit timing/propagation constraints requiring the implementation to confirm state propagation before reporting success. | .claude/specs/82-fix-tabs-create-background/, .claude/specs/120-fix-tabs-close-remaining-count/, .claude/specs/121-fix-tabs-create-background/, .claude/specs/122-fix-tabs-activate-state-propagation/ |
| Global output contracts (format flags, JSON stderr, error cardinality) defined once and assumed to apply everywhere are silently violated by individual commands or framework layers that have their own output behavior. | For each global contract (output format flags, error format, exit codes), add at least one AC per command or command group that verifies compliance. When a framework has its own error-reporting behavior, add an AC asserting framework errors are intercepted and reformatted to match the system's contract. Assert exactly one error object per invocation regardless of how many internal error handlers are traversed. | .claude/specs/96-fix-js-exec-double-json-stderr/, .claude/specs/98-fix-clap-validation-json-stderr/, .claude/specs/114-fix-connect-status-output-flags/ |
| Commands designed to respond to a specific system state may require initialization steps that are blocked by that very state. No AC tests whether the command can bootstrap itself while its own triggering condition is active. | For any command whose purpose is to respond to a particular system state, add an AC: "Given the target state is already active when the command is invoked, the command's initialization sequence completes without blocking or error." Validate that the command can bootstrap itself while the condition it was designed to handle is live. | .claude/specs/86-fix-dialog-commands-timeout-with-open-dialog/, .claude/specs/99-fix-dialog-handle-no-dialog-open/ |
| When a resolution or fallback chain is specified, the spec lists the chain but does not enumerate which operations follow it. Operations that create or modify state may bypass steps that consuming operations follow, or may overwrite fields that downstream operations depend on. | For resolution chains, explicitly list every triggering operation and confirm which steps apply to each. For operations that write shared state, add an AC covering the "write over existing state" scenario, naming which fields are preserved versus replaced. Multi-step chain ACs (create state → reconnect → consume state) expose overwrite gaps that single-step ACs miss. | .claude/specs/87-fix-connect-auto-discover-overwrites-session-pid/, .claude/specs/94-fix-connect-auto-discover-reconnect/ |
| A feature's dependency section references another feature but does not specify the runtime activation state required at execution time. A dependency reference says "this must exist" but not "this must be active before this call," so runtime initialization gaps go undetected. | For features that call into stateful subsystems, add an explicit precondition to ACs: "Given [subsystem/domain] is active/enabled." When multiple commands use the same subsystem, include a cross-command consistency AC verifying that if it works for command A, it also works for command B. | .claude/specs/115-fix-page-screenshot-uid-node-not-found/ |
| When multiple flags logically serve as primary search criteria vs. filters, the spec documents one flag as standalone (with its own AC) while leaving another flag only in combined examples, implicitly excluding it from standalone use even if that exclusion is unintentional. | For commands with multiple optional input modes, write a standalone AC for every flag intended as a primary criterion. Ensure the data requirements validation column uses complete logical expressions covering all valid alternatives (e.g., "Required unless --selector or --role is provided"). | .claude/specs/97-fix-page-find-role-standalone/ |
| A feature introduces a parameter name that collides with an existing global flag or framework-reserved name, causing framework-level conflicts that behavioral ACs cannot detect. | Add a standing check in Data Requirements: verify no new argument name (long or positional identifier) collides with global flags or framework-reserved names. Use content-neutral names for structured payloads (e.g., "input," "payload") rather than names derived from the data format. | .claude/specs/84-fix-form-fill-many-json-arg-collision/ |

---

## Undertested Boundaries

Defects caused by boundary conditions the original feature spec addressed
insufficiently.

| Learning | Recommendation | Evidence (defect specs) |
|----------|---------------|------------------------|
| A spec that defines an overall timeout for a polling or retry loop but not a per-attempt latency budget allows an implementation to choose a blocking I/O strategy that consumes the entire timeout in a handful of attempts. | When a spec requires polling a network endpoint, add a per-request latency upper bound (e.g., "each probe must complete within 500ms") alongside the overall timeout. Specify how the client handles delayed connection close or keep-alive. Do not assume non-blocking I/O will be chosen. | .claude/specs/68-fix-connect-launch-timeout/ |
| A defect fix or feature spec exercises behavior in one runtime configuration without covering configurations where async propagation or protocol behavior differs. Regressions recur specifically in the untested environment. | When a feature touches behavior that can vary by runtime environment (headed vs. headless, local vs. remote, CI vs. interactive), include at least one scenario per distinct environment. Defect fix specs must test in the environment where the defect was observed plus at least one other valid configuration. | .claude/specs/95-fix-tabs-create-background/, .claude/specs/121-fix-tabs-create-background/ |
| A reset or undo command's AC says "all overrides cleared" but different values have different clearing semantics — some return to system defaults, others require baseline restoration. The blanket AC collapses important distinctions. | For reset commands, write per-value post-condition ACs specifying the expected observable state after reset. When reset behavior requires capturing a baseline (e.g., original viewport dimensions), add an explicit requirement that the baseline be recorded at override time. The AC should read "the system is in the same state as before any override was applied." | .claude/specs/100-fix-emulate-reset-viewport/ |
| A spec that requires terminating a process describes the mechanism ("signal is sent") rather than the observable outcome ("process is no longer running"). Mechanism specs permit implementations that perform the action without verifying the result. | Specify process lifecycle requirements as observable post-conditions: "After the operation, the process is no longer running." If escalation is expected (graceful signal then forced termination after timeout), make that a separate AC with timing constraints. Separately specify cleanup of child processes as a named AC. | .claude/specs/101-fix-disconnect-process-not-killed/ |
| A spec lists specific configuration values as a closed inventory rather than describing observable behavioral outcomes. Any value not on the list is silently omitted, and no AC catches the omission because there is no outcome-based verification. | Complement value-inventory ACs with outcome-based ACs that describe verifiable consequences of the configuration. For any launch or configuration scenario, add at least one AC that tests a user-visible or API-visible effect of the values, catching cases where a required value is missing from the list. | .claude/specs/70-fix-enable-automation-flag/ |

---

## Domain-Specific Gaps

Defects caused by domain knowledge the original feature spec failed to capture.

| Learning | Recommendation | Evidence (defect specs) |
|----------|---------------|------------------------|
| A spec assumes the external protocol or API behaves uniformly across all inputs, but certain input characteristics (cross-origin navigation, dynamically-rendered pages, different response structures) cause the protocol to behave differently — emitting different events or returning structurally different data. | For features that delegate to an external protocol, enumerate known behavioral variants and write at least one AC per variant. Use realistic, production-grade data sources in test scenarios alongside minimal synthetic examples. Ask explicitly: "Does the protocol event fire reliably for all valid input categories?" | .claude/specs/72-fix-navigate-back-forward-cross-origin-timeout/, .claude/specs/73-fix-page-snapshot-empty-accessibility-tree/ |
| Output fields defined by name, type, and format (e.g., "timestamp," "size in bytes," "duration in ms") without specifying data source provenance, transformation rules, or measurement start/end boundaries. Format validity and semantic validity are independent properties — a field can be syntactically correct but semantically meaningless. | For derived or transformed output fields, document the data source, the resolution/fallback strategy when the primary source is unreliable or zero, and the measurement boundaries (what event starts the clock, what event ends it). Add at least one AC that validates semantic correctness (e.g., "timestamp year matches current year," "duration approximately matches the recording window"). | .claude/specs/116-fix-network-list-timestamps/, .claude/specs/117-fix-network-list-size-zero/, .claude/specs/118-fix-perf-record-duration/ |
| Optional fields in the output schema have no explicit serialization contract for the absent case. "Optional" at the domain level is conflated with "omitted from output." The semantic distinction between null (unmeasurable) and zero (measured as zero) is not specified, causing both to appear as null or both as omitted. | For every optional output field, add an AC stating: "When the value cannot be determined, the field MUST appear as `null`." Separately specify when a zero value is semantically correct (e.g., zero observed events produces `0.0`, not `null`). Distinguish "we measured it and the value is zero" from "we could not measure it." | .claude/specs/75-fix-perf-vitals-missing-metrics/, .claude/specs/119-fix-perf-vitals-null-cls-ttfb/ |
| A spec requires filtering or excluding items from a hierarchical data structure but only considers leaf-level exclusion. When filtered items appear as intermediate ancestors, their descendants are silently dropped because the spec does not address child re-parenting. | For filtering on tree-structured data, write explicit ACs for each structural position of the filtered element: leaf (excluded silently), sibling (excluded; adjacents unaffected), and intermediate ancestor (excluded; descendants promoted to nearest non-excluded ancestor). Add the question: "When a filtered node has children, what happens to those children?" | .claude/specs/83-fix-snapshot-ignored-nodes/ |
| A defect fix spec addresses the specific code path that caused the observed failure but does not audit sibling code paths that share the same problematic pattern. The defect recurs in a narrower form through an unexamined path, and fix specs that address only the immediate symptom leave the root pattern partially open. | When specifying a defect fix, include a "path audit" requirement: enumerate all code paths that share the same pattern as the one that failed, and either fix them or document them as explicit out-of-scope follow-ups. For data-extraction fixes, list the ordered set of extraction strategies per metric and define fallback behavior if all strategies fail. | .claude/specs/99-fix-dialog-handle-no-dialog-open/, .claude/specs/119-fix-perf-vitals-null-cls-ttfb/ |
| When a feature's data retrieval relies on subscribing to events from an external protocol, the spec must account for the ephemeral nature of events — they exist only at the moment they fire and cannot be queried retroactively. If the consumer is not connected when the event fires, the data is permanently lost. A spec that says "track via events" without requiring an alternative data path for missed events is incomplete. | For features that depend on event-driven data from external systems, always require a fallback data retrieval mechanism that does not depend on having been connected at event-fire time. Ask: "If the consumer connects after the event has already fired, how does it obtain the same data?" If the protocol offers no retroactive query, the spec must require a proactive instrumentation or persistence strategy (e.g., injecting interceptors, storing state in an accessible side channel). | .claude/specs/134-fix-dialog-info-wrong-type-empty-message/ |
