# Requirements: Console Read Runtime Messages

**Issue**: #146
**Date**: 2026-02-18
**Status**: Draft
**Author**: Claude (writing-specs)

---

## User Story

**As an** AI agent automating browser workflows
**I want** `console read` to show console messages generated by runtime interactions (clicks, form fills, JS execution)
**So that** I can detect JavaScript errors or warnings that occurred during my automation steps

---

## Background

Issue #103 fixed `console read` returning empty arrays by adding a page-reload approach -- the command reloads the page and captures console messages emitted during the reload. This works for static page-load scripts but fundamentally cannot capture messages from runtime interactions.

In a typical AI agent workflow, the agent navigates to a page, interacts with it (clicks buttons, fills forms via `interact click`, `form fill`, `js exec`), and then wants to check for console errors. The current reload-based approach destroys runtime state and re-runs page-load scripts, so any messages from interactions are lost.

Investigation (documented in issue #146 comments) revealed that CDP maintains an internal replay buffer for `Runtime.consoleAPICalled` events. When a new session calls `Runtime.enable`, all cached console messages are replayed immediately. This eliminates the need for page reload entirely, preserving both runtime messages and page state.

---

## Acceptance Criteria

**IMPORTANT: Each criterion becomes a Gherkin BDD test scenario.**

### AC1: Console read captures messages from page interactions

**Given** an agent has navigated to a page and triggered console messages via `interact click` (e.g., clicking a button that logs to console)
**When** I run `chrome-cli console read`
**Then** the output includes the messages generated by the interaction
**And** each entry has `id`, `type`, `text`, and `timestamp` fields

**Example**:
- Given: navigated to a page with a button that calls `console.log('clicked')` on click, then clicked the button via `interact click`
- When: `chrome-cli console read`
- Then: output includes `{"id": 0, "type": "log", "text": "clicked", ...}`

### AC2: Console read captures messages from js exec across invocations

**Given** an agent has run `chrome-cli js exec "console.log('test'); console.error('oops')"` in a prior CLI invocation
**When** I run `chrome-cli console read` in a subsequent, independent CLI invocation
**Then** the output includes both the log and error messages from the prior invocation

**Example**:
- Given: `chrome-cli js exec "console.log('test'); console.error('oops')"` completed successfully
- When: `chrome-cli console read`
- Then: output includes entries with text "test" (type "log") and "oops" (type "error")

### AC3: Console read still returns page-load messages (no regression)

**Given** a page has console output during initial load (e.g., from inline scripts)
**When** I run `chrome-cli console read`
**Then** the page-load messages are still captured
**And** each entry has `id`, `type`, `text`, and `timestamp` fields

### AC4: Console read preserves page state (no reload)

**Given** an agent has navigated to a page and modified runtime state (e.g., filled a form, expanded a menu, scrolled)
**When** I run `chrome-cli console read`
**Then** the page state is preserved (form values, DOM changes, scroll position remain intact)
**And** no page reload occurs

### AC5: Console follow streaming still works (no regression)

**Given** Chrome is running with a page open
**When** I run `chrome-cli console follow --timeout 2000` and console messages are generated
**Then** messages are streamed as JSON lines unchanged
**And** the existing follow behavior is preserved

### AC6: Existing filters work on all captured messages

**Given** an agent has generated log, warn, and error console messages via runtime interactions
**When** I run `chrome-cli console read --errors-only`
**Then** only error-level messages are returned from the full set of captured messages (including runtime interaction messages)

**And when** I run `chrome-cli console read --type warn`
**Then** only warn-level messages are returned

**And when** I run `chrome-cli console read --limit 2`
**Then** at most 2 messages are returned

### AC7: Console read captures accumulated messages from multiple interactions

**Given** an agent has performed multiple interactions across separate CLI invocations (e.g., `js exec` three times, each generating console messages)
**When** I run `chrome-cli console read`
**Then** all messages from all prior interactions are present in the output
**And** messages are ordered chronologically by timestamp

### Generated Gherkin Preview

```gherkin
Feature: Console Read Runtime Messages
  As an AI agent automating browser workflows
  I want console read to show console messages from runtime interactions
  So that I can detect JavaScript errors or warnings from automation steps

  Scenario: Console read captures messages from page interactions
    Given a page with a button that logs to console on click
    And the button has been clicked via interact click
    When I run "chrome-cli console read"
    Then the output includes the interaction-generated messages
    And each entry has id, type, text, and timestamp fields

  Scenario: Console read captures messages from js exec across invocations
    Given js exec has generated console messages in a prior invocation
    When I run "chrome-cli console read" in a new invocation
    Then the output includes messages from the prior invocation

  Scenario: Console read still returns page-load messages
    Given a page has console output from inline scripts during load
    When I run "chrome-cli console read"
    Then the page-load messages are captured

  Scenario: Console read preserves page state
    Given a page has been modified via runtime interactions
    When I run "chrome-cli console read"
    Then the page state is preserved with no reload

  Scenario: Console follow streaming still works
    Given Chrome is running with a page open
    When I run "chrome-cli console follow --timeout 2000"
    And console messages are generated
    Then messages are streamed as JSON lines unchanged

  Scenario: Filters work on all captured messages
    Given runtime interactions have generated log, warn, and error messages
    When I run "chrome-cli console read --errors-only"
    Then only error-level messages are returned

  Scenario: Accumulated messages from multiple interactions
    Given multiple js exec invocations have each generated console messages
    When I run "chrome-cli console read"
    Then all messages from all invocations are present
    And messages are ordered chronologically
```

---

## Functional Requirements

| ID | Requirement | Priority | Notes |
|----|-------------|----------|-------|
| FR1 | `console read` must capture messages generated by runtime interactions between CLI invocations | Must | Core feature requirement |
| FR2 | `console read` must not reload the page | Must | Preserves SPA state and runtime modifications |
| FR3 | Page-load console messages must still be captured (no regression from #103 fix) | Must | CDP replay buffer includes page-load messages |
| FR4 | `console follow` streaming behavior must be preserved | Must | No changes to follow path |
| FR5 | Existing filters (`--type`, `--errors-only`, `--limit`, `--page`) must work on all captured messages | Should | Filters apply after collection |
| FR6 | Messages from multiple prior interactions must accumulate in the output | Should | CDP replay buffer preserves all messages |
| FR7 | Message collection should complete within ~200ms (idle timeout drain) | Should | Vs multi-second reload cycle |

---

## Non-Functional Requirements

| Aspect | Requirement |
|--------|-------------|
| **Performance** | `console read` should complete in < 500ms (vs current multi-second reload cycle) |
| **Reliability** | CDP replay buffer must be drained before the idle timeout expires; subscribe before `Runtime.enable` to avoid dropped events |
| **Platforms** | macOS, Linux, Windows (all platforms supported by chrome-cli) |

---

## Data Requirements

### Input Data

| Field | Type | Validation | Required |
|-------|------|------------|----------|
| `MSG_ID` | positive integer | Must be a valid message index | No (positional) |
| `--type` | comma-separated string | Each value must be a valid console type | No |
| `--errors-only` | boolean flag | Conflicts with `--type` | No |
| `--limit` | positive integer | Must be > 0, default 50 | No |
| `--page` | non-negative integer | Must be >= 0, default 0 | No |
| `--include-preserved` | boolean flag | None | No |
| `--tab` | string (tab ID or index) | Must be a valid tab | No |

### Output Data

| Field | Type | Description |
|-------|------|-------------|
| `id` | integer | Message index within the collection |
| `type` | string | Console message type (log, error, warn, etc.) |
| `text` | string | Formatted message text |
| `timestamp` | string | ISO 8601 timestamp |
| `url` | string | Source URL where message originated |
| `line` | integer | Source line number |
| `column` | integer | Source column number |

---

## Dependencies

### Internal Dependencies
- [x] Issue #4 -- CDP client (implemented)
- [x] Issue #6 -- Session management (implemented)
- [x] Issue #18 -- Console message reading (implemented, being modified)
- [x] Issue #103 -- Console read empty array fix (implemented, approach being replaced)

### External Dependencies
- Chrome/Chromium with CDP support (Runtime domain replay buffer behavior)

### Blocked By
- None (all dependencies resolved)

---

## Out of Scope

- Long-running background daemon for persistent console monitoring
- Changes to `js exec` inline console capture
- Console message persistence across page navigations (unless `--include-preserved`)
- Changes to `console follow` behavior
- Changes to CLI argument structure or new flags
- Navigation-aware filtering changes (replay buffer provides all messages without navigation context)

---

## Success Metrics

| Metric | Target | Measurement |
|--------|--------|-------------|
| All BDD scenarios pass | 100% | `cargo test --test bdd` |
| Runtime messages captured | Messages from `js exec`, `interact click` visible in `console read` | Manual smoke test |
| Page state preserved | No page reload occurs during `console read` | Manual verification |
| Performance improvement | < 500ms vs multi-second reload | Timing comparison |

---

## Open Questions

- (none -- solution validated per issue #146 comments)

---

## Validation Checklist

- [x] User story follows "As a / I want / So that" format
- [x] All acceptance criteria use Given/When/Then format
- [x] No implementation details in requirements
- [x] All criteria are testable and unambiguous
- [x] Success metrics are measurable
- [x] Edge cases and error states are specified
- [x] Dependencies are identified
- [x] Out of scope is defined
- [x] Open questions are documented (or resolved)
- [x] Cross-invocation state persistence AC included (retrospective learning)
- [x] Multiple accumulation scenarios covered (retrospective learning)
